import React, { useEffect, useRef, useState, useCallback } from "react";
import { Grid, IconButton, Table, TableBody, Button, TableCell, TableHead, TableRow, Card, CardContent, Alert, CircularProgress } from "@mui/material";
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import SaveAsIcon from '@mui/icons-material/SaveAs';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import { debounce } from 'lodash';
import dayjs from "dayjs";
import * as XLSX from 'xlsx';
import { useGetFinancialDetailsQuery, useSaveFinancialDetailsFormTermsMutation, useUpdateCommentByNIdMutation } from "../../../features/application-form/applicationForm";
import { useAppSelector } from "../../../app/hooks";
import ErrorMessageGlobal from "../../../components/framework/ErrorMessageGlobal";
import FormLoader from "../../../loader/FormLoader";
import { OnlineSnackbar } from "../../../components/shared/OnlineSnackbar";
import ConfirmationAlertDialog from '../../../models/application-form/ConfirmationAlertDialog';
import { DocumentAPI } from "../../../features/application-form/documentUpload";
import CloudDownloadIcon from '@mui/icons-material/CloudDownload';
import { MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB, UPLOADINGTEXT } from "../../../utlis/constants";
import FullScreenLoader from "../../../components/common/FullScreenLoader";
import FullScreenLoaderNoClose from "../../../components/common/FullScreenLoaderNoClose";
import DrawerResponseComponent from "../../../components/DrawerComponent/DrawerResponseComponent";
import NotificationSectionWiseButton from "../../../components/DrawerComponent/NotificationSectionWiseButton";
import Notification from '../../../components/shared/Notification';
const FinancialDetailsComponent = () => {
    const [addFinancialdetails] = useSaveFinancialDetailsFormTermsMutation();
    const { applId, transactionData } = useAppSelector((state: any) => state.userStore);
    const { data: financialDetails, isLoading, isError } = useGetFinancialDetailsQuery(applId);
    const [formData, setFormData] = useState<any[]>([]);
    const [isSaving, setIsSaving] = useState(false);
    const [lastSaveTime, setLastSaveTime] = useState<string | null>(null);
    const [openConfirmation, setOpenConfirmation] = useState(false);
    const [actionVal, setActionVal] = useState<any>("");
    const [formDisabled, setFormDisabled] = useState(false);
    const [openSnackbar, setOpenSnackbar] = useState<boolean>(false);
    const [snackMsg, setSnackMsg] = useState<any>("");
    const [severity, setSeverity] = useState<string | any>("success");
    const debouncedSave = useRef<any>();
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [isUploading, setIsUploading] = useState<boolean>(false);
    const [excelUploadError, setExcelUploadError] = useState<string | null>(null);
    const { schemeCode } = useAppSelector((state) => state.userStore);
    const [openSectionsData, setOpenSectionsData] = React.useState<any[]>([]);

    const calculateSums = useCallback((data: any[]) => {
        return data.map(item => {
            const newItem = { ...item };
            const columns = ['valAsonTMinus2', 'valAsonTMinus1', 'valAsonT', 'qtrVal', 'tplus1Val', 'tplus2Val'];

            if (item.particulars === "Total Investments (in ₹ crore)") {
                const investmentRows = data.filter(row =>
                    [
                        "- Investments in group cos.",
                        "- Investments in SRs/securitization",
                        "- Investments in liquid assets (G-secs/ Mutual Funds)",
                        "- Investments in debt securities",
                        "- Other Investments (in ₹ crore)"
                    ].includes(row.particulars)
                );
                columns.forEach((column: any) => {
                    newItem[column] = investmentRows
                        .reduce((acc, curr) => acc + (parseFloat(curr[column]) || 0), 0)
                        .toFixed(2);
                });
            }

            if (item.particulars === "Total AUM (on-book+ off-book) (in ₹ crore)") {
                const aumRows = data.filter(row =>
                    [
                        "On-Book AUM (in ₹ crore)",
                        "Off-Book AUM (in ₹ crore)"
                    ].includes(row.particulars)
                );
                columns.forEach((column: any) => {
                    newItem[column] = aumRows
                        .reduce((acc: any, curr: any) => acc + (parseFloat(curr[column]) || 0), 0)
                        .toFixed(2);
                });
            }

            if (item.particulars === "Total Income (in ₹ crore)") {
                const incomeRows = data.filter(row =>
                    [
                        "Interest Income (in ₹ crore)",
                        "Fee and Commission Income (in ₹ crore)",
                        "Net gain on derecognition of financial instruments (in ₹ crore)",
                        "Net gain on fair value changes (in ₹ crore)",
                        "Other Income (in ₹ crore)"
                    ].includes(row.particulars)
                );
                columns.forEach(column => {
                    newItem[column] = incomeRows
                        .reduce((acc: any, curr: any) => acc + (parseFloat(curr[column]) || 0), 0)
                        .toFixed(2);
                });
            }

            if (item.particulars === "Operating Expenses (in ₹ crore)") {
                const expenseRows = data.filter(row =>
                    [
                        "-Employee Cost (in ₹ crore)",
                        "-Marketing Cost (in ₹ crore)",
                        "-IT Expenses (in ₹ crore)",
                        "-Other Operating Expenses (in ₹ crore)"
                    ].includes(row.particulars)
                );
                columns.forEach(column => {
                    newItem[column] = expenseRows
                        .reduce((acc: any, curr: any) => acc + (parseFloat(curr[column]) || 0), 0)
                        .toFixed(2);
                });
            }

            if (item.particulars === "Pre-Provisioning Operational Profits (in ₹ crore)") {
                const incomeRows = data.filter(row =>
                    [
                        "Interest Income (in ₹ crore)",
                        "Fee and Commission Income (in ₹ crore)",
                        "Net gain on derecognition of financial instruments (in ₹ crore)",
                        "Net gain on fair value changes (in ₹ crore)",
                        "Other Income (in ₹ crore)"
                    ].includes(row.particulars)
                );

                const operatingExpenseRows = data.filter(row =>
                    [
                        "-Employee Cost (in ₹ crore)",
                        "-Marketing Cost (in ₹ crore)",
                        "-IT Expenses (in ₹ crore)",
                        "-Other Operating Expenses (in ₹ crore)",
                        "Interest Expense (in ₹ crore)"
                    ].includes(row.particulars)
                );

                columns.forEach(column => {
                    const totalIncome = incomeRows.reduce((acc, curr) => acc + (parseFloat(curr[column]) || 0), 0);
                    const totalOperatingExpenses = operatingExpenseRows.reduce((acc, curr) => acc + (parseFloat(curr[column]) || 0), 0);
                    newItem[column] = (totalIncome - totalOperatingExpenses).toFixed(2);
                });
            }

            if (item.particulars === "PAT after Exceptional and Extraordinary Items (in ₹ crore)") {
                const expenseRows = data.filter(row =>
                    [
                        "Profit After Tax (in ₹ crore)",
                        "Exceptional and Extraordinary income and losses (in ₹ crore)"
                    ].includes(row.particulars)
                );
                columns.forEach(column => {
                    newItem[column] = expenseRows
                        .reduce((acc: any, curr: any) => acc + (parseFloat(curr[column]) || 0), 0)
                        .toFixed(2);
                });
            }

            return newItem;
        });
    }, []);

    useEffect(() => {
        if (financialDetails) {
            const dataWithApplId = financialDetails.map((item: any) => ({
                ...item,
                applId
            }));
            setFormData(dataWithApplId);
            const isSubmitted = dataWithApplId.some((item: any) => item.saveStatus === '02');
            setFormDisabled(isSubmitted);
        }
    }, [financialDetails, applId]);

    const saveFormData = async (dataToSave: any[], status = '01') => {
        setIsSaving(true);
        setIsUploading(true);
        try {
            const dataWithStatus = dataToSave.map(item => ({
                ...item,
                saveStatus: status
            }));
            if (await addFinancialdetails(dataWithStatus).unwrap()) {
                setLastSaveTime(dayjs().format('YYYY-MM-DD HH:mm:ss'));
                setOpenSnackbar(true);
                setIsUploading(false);
                setSeverity("success");
                setSnackMsg(status === '02' ? "Section submitted successfully" : "Record saved successfully");
                if (status === '02') {
                    setFormDisabled(true);
                }
            }
        } catch (error) {
            console.error("Error saving data:", error);
            setOpenSnackbar(true);
            setIsUploading(false);
            setSeverity("error");
            setSnackMsg("Failed to save");
        } finally {
            setIsSaving(false);
        }
    };

    useEffect(() => {
        debouncedSave.current = debounce((dataToSave: any[]) => {
            saveFormData(dataToSave);
        }, 5000);

        return () => {
            debouncedSave.current?.cancel();
        };
    }, []);

    const handleExternalDownload = async () => {
        try {
            const response = await DocumentAPI.downloadExternalTemplate('04', schemeCode);
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(new Blob([response.data]));
            downloadLink.download = 'Financial details_upload template.xlsx';
            downloadLink.target = '_blank';
            downloadLink.click();
        } catch (error: any) {
            setOpenSnackbar(true);
            setSeverity("error");
            setSnackMsg('Failed to download template document.');
        }
    };

    const handleInputChange = (
        index: number,
        column: string,
        value: string
    ) => {
        if (formDisabled) return;
        const newData = [...formData];
        const rule = newData[index].rule;
        let regex;
        if (rule === 'P') {
            regex = /^\d{0,10}(\.\d{0,2})?$/;
        } else if (rule === 'N') {
            regex = /^-\d{0,10}(\.\d{0,2})?$/;
        } else if (rule === 'B') {
            regex = /^-?\d{0,10}(\.\d{0,2})?$/;
        } else {
            regex = /^-?\d{0,10}(\.\d{0,2})?$/;
        }

        if (regex.test(value)) {
            const numericValue = parseFloat(value);
            if (rule === 'P' && numericValue < 0) return;
            if (rule === 'N' && numericValue > 0) return;
            newData[index][column] = value;
            newData[index][column] = value;

            const calculatedData = calculateSums(newData);
            setFormData(calculatedData);
            debouncedSave.current(calculatedData);
        }
    };

    const handleSubmit = async () => {
        saveFormData(formData);
    };

    const handleClickSetAction = (action: string) => {
        setActionVal(action);
        if (action === '02') {
            setOpenConfirmation(true);
        }
    };

    const handleCloseConfirmation = () => {
        setActionVal(null);
        setOpenConfirmation(false);
    };

    const handleSubmitConfirmation = () => {
        setOpenConfirmation(false);
        saveFormData(formData, '02');
    };

    const isCalculatedField = useCallback((particulars: string) => {
        return [
            "Total Investments (in ₹ crore)",
            "Total AUM (on-book+ off-book) (in ₹ crore)",
            "Total Income (in ₹ crore)",
            "Operating Expenses (in ₹ crore)",
            "Pre-Provisioning Operational Profits (in ₹ crore)",
            "PAT after Exceptional and Extraordinary Items (in ₹ crore)"
        ].includes(particulars);
    }, []);

    const handleClose = () => {
        setOpenSnackbar(false);
    };

    const showQuarterColumn = transactionData?.lstAudQ !== "Not Applicable";

    const getTableColumns = () => {
        const baseColumns = [
            { key: 'particulars', label: 'Particulars' },
            { key: 'valAsonTMinus2', label: transactionData?.lstAudYrTm2, subLabel: 'Audited' },
            { key: 'valAsonTMinus1', label: transactionData?.lstAudYrTm1, subLabel: 'Audited' },
            { key: 'valAsonT', label: transactionData?.lstAudYrT, subLabel: 'Audited' },
        ];

        if (showQuarterColumn) {
            baseColumns.push({ key: 'qtrVal', label: transactionData?.lstAudQ, subLabel: 'Unaudited' });
        }

        return [
            ...baseColumns,
            { key: 'tplus1Val', label: transactionData?.lstAudYrTp1, subLabel: 'Projections' },
            { key: 'tplus2Val', label: transactionData?.lstAudYrTp2, subLabel: 'Projections' },
        ];
    };

    const columns = getTableColumns();
    const columnMappings = {
        'T-2': 'valAsonTMinus2',
        'T-1': 'valAsonTMinus1',
        'Latest audited FY (T)': 'valAsonT',
        'Latest unaudited quarter/half year/9M': 'qtrVal',
        'T+1': 'tplus1Val',
        'T+2': 'tplus2Val'
    };

    const handleExcelUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        if (!file.name.endsWith(".xlsx") && !file.name.endsWith(".xls")) {
            setExcelUploadError("Please upload a valid Excel file (.xlsx or .xls)");
            return;
        }
        if (file.size > MAX_FILE_SIZE_BYTES) {
            setExcelUploadError(`File size should not exceed ${MAX_FILE_SIZE_MB} MB`);
            return;
        }

        try {
            setIsUploading(true);

            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, {
                type: 'array',
                raw: true,
                cellDates: true,
                cellNF: true
            });

            const firstSheetName = workbook.SheetNames[1];
            const worksheet = workbook.Sheets[firstSheetName];

            const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                header: 1,
                defval: '',
                raw: false
            });

            const headerRowIndex = jsonData.findIndex((row: any) =>
                row.includes('Particulars-IGAAP/IND-AS') || row.includes('Particulars'));

            if (headerRowIndex === -1) {
                throw new Error('Invalid Excel format: Header row not found');
            }

            const headerRow: any = jsonData[headerRowIndex];

            const columnIndices: any = {};
            headerRow.forEach((header: string, index: number) => {
                const mappedColumn = columnMappings[header as keyof typeof columnMappings];
                if (mappedColumn) {
                    columnIndices[index] = mappedColumn;
                }
            });

            const newFormData = [...formData];

            jsonData.slice(headerRowIndex + 2).forEach((row: any, rowIndex: number) => {
                if (!row[0] || typeof row[0] !== 'string') return;

                const particulars = row[0].trim();
                const existingRowIndex = newFormData.findIndex(
                    item => item.particulars.trim() === particulars
                );

                if (existingRowIndex !== -1) {
                    const rule = newFormData[existingRowIndex].rule;
                    const isReserves = particulars === "Reserves";

                    Object.entries(columnIndices).forEach(([excelIndex, formField]: any) => {
                        let cellValue = row[excelIndex];

                        if (cellValue !== undefined && cellValue !== '') {
                            if (typeof cellValue === 'object' && cellValue.w) {
                                cellValue = cellValue.w;
                            }

                            const numValue = typeof cellValue === 'number' ?
                                cellValue :
                                parseFloat(cellValue.toString().replace(/[^\d.-]/g, ''));

                            if (!isNaN(numValue)) {
                                if (isReserves) {
                                    newFormData[existingRowIndex][formField] = cellValue.toString();
                                } else if (
                                    (rule === 'P' && numValue >= 0) ||
                                    (rule === 'N' && numValue <= 0) ||
                                    rule === 'B' ||
                                    !rule
                                ) {
                                    newFormData[existingRowIndex][formField] = numValue.toFixed(2);
                                }
                            } else if (isReserves) {
                                newFormData[existingRowIndex][formField] = cellValue.toString();
                            } else {
                                newFormData[existingRowIndex][formField] = '0.00';
                            }
                        } else {
                            newFormData[existingRowIndex][formField] = isReserves ? '' : '0.00';
                        }
                    });
                }
            });

            const calculatedData = calculateSums(newFormData);
            setFormData(calculatedData);
            setOpenSnackbar(true);
            setSeverity("success");
            setSnackMsg("Excel data imported successfully");

            if (fileInputRef.current) {
                fileInputRef.current.value = '';
            }
            debouncedSave.current(calculatedData);

        } catch (error) {
            console.error('Error processing Excel file:', error);
            setOpenSnackbar(true);
            setIsUploading(false);
            setSeverity("error");
            setSnackMsg("Error processing Excel file. Please check the format.");
        } finally {
            setIsUploading(false);
        }
    };

    const handleUploadClick = () => {
        fileInputRef.current?.click();
    };
    const [updateCommentByNId] = useUpdateCommentByNIdMutation();
    const { opensections } = useAppSelector((state) => state.userStore);
    const [getOpenSectionsData, setOpenSections] = useState<any[]>([]);
    const [open, setOpen] = React.useState<any>(false);
    const [getNotiId, setNotiId] = React.useState<any>('');

    const toggleDrawer = (newOpen: boolean) => () => {
        setOpen(true);
    };
    const handleButtonClick = (notfId: any) => {
        setOpen(true);
        setNotiId(notfId);
    };
    useEffect(() => {
        if (opensections && opensections.length > 0) {
            setOpenSections(opensections);
        }
    }, [opensections]);

    if (isLoading) return <FormLoader />;
    if (isError) return <ErrorMessageGlobal status={isError} />;
    if (isUploading) return <FullScreenLoader open={isUploading} setOpenModal={setIsUploading} text={UPLOADINGTEXT} />;

    return (
        <div className="custome-form">
            <Grid item xs={12} className="opensections-sticky-css">
                <Grid
                    className="pb-0"
                    item
                    xs={12}
                    display="flex"
                    justifyContent="end">
                    {getOpenSectionsData && getOpenSectionsData.length > 0 && (() => {
                        const matchedItem = getOpenSectionsData.find(
                            (item: any) => item?.sectionId === "04" && item?.subSectionId === "01"
                        );
                        return matchedItem ? (
                            <div className="openSection-item">
                                <NotificationSectionWiseButton
                                    label="Respond"
                                    handleClick={() => handleButtonClick(matchedItem?.notfId)}
                                    className="btn-primary-css--"
                                    notfId={matchedItem?.notfId}
                                    getOpenSectionsData={getOpenSectionsData}

                                />
                            </div>
                        ) : null;
                    })()}
                    <DrawerResponseComponent
                        open={open}
                        toggleDrawer={toggleDrawer}
                        notfId={getNotiId}
                        detailsData={''}
                        postDataTrigger={updateCommentByNId}
                        setOpen={setOpen}
                    />
                </Grid>
            </Grid>


            {!transactionData ?
                <Notification /> : <>
                    {!formDisabled && (
                        <div className="up_btns">
                            <input
                                type="file"
                                ref={fileInputRef}
                                accept=".xlsx,.xls"
                                onChange={handleExcelUpload}
                                style={{ display: 'none' }}
                            />

                            <Button
                                variant="contained"
                                color="primary"
                                component="span"
                                onClick={handleUploadClick}
                                disabled={isUploading}
                                style={{ marginLeft: '0px', padding: '4px 10px', textTransform: 'capitalize' }}
                                startIcon={isUploading ? <CircularProgress size={18} color="inherit" /> : <UploadFileIcon style={{ fontSize: '20px' }} />}
                            >
                                {isUploading ? "Uploading..." : "Upload Excel"}
                            </Button>

                            <Button
                                variant="contained"
                                color="primary"
                                onClick={handleExternalDownload}
                                className="sbmtBtn dwldBtn"
                            >
                                Download template <CloudDownloadIcon />
                            </Button>
                        </div>
                    )}
                    {excelUploadError && (
                        <div className="error-message mt-1 text-danger">
                            {excelUploadError}
                        </div>
                    )}
                    <ConfirmationAlertDialog
                        id={applId}
                        type={4}
                        open={openConfirmation}
                        handleClose={handleCloseConfirmation}
                        handleDelete={handleSubmitConfirmation}
                        values={formData}
                    />
                    {lastSaveTime && (
                        <div className="text-muted text-right">
                            <p className="autoSv" style={{ marginLeft: '0px' }}>
                                <span><b><CheckCircleOutlineIcon /> Last saved at:</b> {lastSaveTime}</span>
                            </p>
                        </div>
                    )}
                    <div className="wrap-inner-table mt-0">
                        <Table sx={{ minWidth: 650 }} aria-label="simple table">
                            <TableHead>
                                <TableRow>
                                    {columns.map((col: any, index: any) => (
                                        <TableCell key={index}>
                                            <b>{col.label}</b>
                                        </TableCell>
                                    ))}
                                </TableRow>
                                <TableRow>
                                    <TableCell><b>(All amount is In ₹ crore)</b></TableCell>
                                    {columns.slice(1).map((col: any, index: any) => (
                                        <TableCell key={index}>
                                            <b>{col.subLabel}</b>
                                        </TableCell>
                                    ))}
                                </TableRow>
                            </TableHead>
                            <TableBody style={{ background: '#fff' }}>
                                {formData.map((item: any, index: number) => (
                                    <TableRow key={index}>
                                        <TableCell>
                                            <p>{item?.particulars}</p>
                                        </TableCell>
                                        {columns.slice(1).map((col: any) => (
                                            <TableCell key={col.key}>
                                                <input
                                                    type={item?.particulars === "Reserves" ? "text" : "number"}
                                                    value={item[col.key] || ''}
                                                    disabled={isCalculatedField(item.particulars) || formDisabled}
                                                    onChange={(e) => {
                                                        const value = e.target.value;
                                                        handleInputChange(index, col.key, value);
                                                    }}
                                                    style={{
                                                        width: '100%',
                                                        padding: '8px',
                                                        border: '1px solid #b3b3b3',
                                                        borderRadius: '4px'
                                                    }}
                                                />
                                            </TableCell>
                                        ))}
                                    </TableRow>
                                ))}
                            </TableBody>
                        </Table>

                        {!formDisabled && (
                            <div>
                                <Button
                                    variant="contained"
                                    className="sbmtBtn m-3"
                                    color="primary"
                                    onClick={handleSubmit}
                                    disabled={isSaving}
                                >
                                    Save <CheckCircleOutlineIcon />
                                </Button>
                                <Button
                                    variant="contained"
                                    className="sbmtBtn sbmtBtn_scn m-0"
                                    color="primary"
                                    onClick={() => handleClickSetAction('02')}
                                    disabled={isSaving}
                                >
                                    Submit <SaveAsIcon />
                                </Button>
                            </div>
                        )}
                    </div>
                    <OnlineSnackbar
                        open={openSnackbar}
                        msg={snackMsg}
                        severity={severity}
                        handleSnackClose={handleClose}
                    />
                </>
            }
        </div>
    );
};

export default FinancialDetailsComponent;


import React, { useState, useEffect } from 'react';
import {
  Card,
  Grid,
  Typography,
  Button,
  IconButton,
  Box,
  CircularProgress,
  Alert,
  Snackbar,
  Backdrop,
  Drawer,
  List,
  ListItem,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from '@mui/material';
import PreviewIcon from '@mui/icons-material/Preview';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import SnippetFolderIcon from '@mui/icons-material/SnippetFolder';
import CloseIcon from '@mui/icons-material/Close';
import ReportProblemIcon from '@mui/icons-material/ReportProblem';
import {
  CloudDownload as DownloadIcon,
  Save as SaveIcon,
  Delete as DeleteIcon,
  Upload as UploadIcon,
  Description as FileIcon,
  Download as SampleDownloadIcon
} from '@mui/icons-material';
import { DocumentAPI } from '../../../features/application-form/documentUpload';
import moment from 'moment';
import shadows from '@mui/material/styles/shadows';
import HighlightOffIcon from '@mui/icons-material/HighlightOff';

interface DocumentDetail {
  docId: string;
  docDesc: string;
  sampleFormatFlg: string;
  countOfRecord: number;
  mandtoryFlg: string;
}

interface UploadedDocument {
  applId: string;
  slNo: number;
  docId: string;
  filename: string;
  filetype: string;
  docUrlPath: string;
}

interface FileWithPreview extends File {
  previewUrl?: string;
}

interface SelectedFileState {
  file: FileWithPreview | null;
  previewUrl?: string;
}

interface ErrorState {
  message: string;
  severity: 'error' | 'warning' | 'info' | 'success';
}

interface DeleteDialogState {
  open: boolean;
  applId?: string;
  slNo?: number;
  filename?: string;
  docId?: string;
}

const DocumentUploads: React.FC<{ applId: string }> = ({ applId }) => {
  const [documentDetails, setDocumentDetails] = useState<DocumentDetail[]>([]);
  const [uploadedDocs, setUploadedDocs] = useState<{ [key: string]: UploadedDocument[] }>({});
  const [selectedFiles, setSelectedFiles] = useState<{ [key: string]: SelectedFileState }>({});
  const [loading, setLoading] = useState<{ [key: string]: boolean }>({});
  const [pageLoading, setPageLoading] = useState(true);
  const [error, setError] = useState<ErrorState | null>(null);
  const [downloadLoading, setDownloadLoading] = useState<{ [key: string]: boolean }>({});
  const [sampleDownloadLoading, setSampleDownloadLoading] = useState<{ [key: string]: boolean }>({});
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [selectedDocId, setSelectedDocId] = useState<string | null>(null);
  const [deleteDialog, setDeleteDialog] = useState<DeleteDialogState>({ open: false });

  const showError = (message: string, severity: ErrorState['severity'] = 'error') => {
    setError({ message, severity });
  };

  const handleCloseError = () => {
    setError(null);
  };

  const fetchDocumentList = async () => {
    setPageLoading(true);
    try {
      const response = await DocumentAPI.getDocumentList(applId);
      setDocumentDetails(response.data.data || []);
      // if (response.data.data && response.data.data.length > 0) {
      //   await Promise.all(
      //     response.data.data.map((doc: DocumentDetail) => fetchUploadedDocs(doc.docId))
      //   );
      // }
    } catch (error: any) {
      showError(error.response?.data?.message || 'Failed to fetch document list');
    } finally {
      setPageLoading(false);
    }
  };

  const fetchUploadedDocs = async (docId: string) => {
    try {
      const response = await DocumentAPI.getUploadedDocList(applId, docId);
      setUploadedDocs(prev => ({
        ...prev,
        [docId]: response?.data?.data || []
      }));
    } catch (error: any) {
      showError(error.response?.data?.message || 'Failed to fetch uploaded documents');
    }
  };

  const validateFile = (file: File): boolean => {
    const maxSize = 10 * 1024 * 1024; // 10MB

    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'image/jpeg',
      'image/png',
      'application/vnd.ms-excel', // .xls
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' // .xlsx
    ];


    if (file.size > maxSize) {
      showError('File size should not exceed 10MB');
      return false;
    }

    if (!allowedTypes.includes(file.type)) {
      showError('Invalid file type. Please upload PDF, DOC, DOCX, JPG, or PNG files');
      return false;
    }

    return true;
  };

  const handleFileChange = (docId: string, event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files.length > 0) {
      const file = event.target.files[0];

      if (!validateFile(file)) {
        event.target.value = '';
        return;
      }

      const previewUrl = URL.createObjectURL(file);
      setSelectedFiles(prev => ({
        ...prev,
        [docId]: { file, previewUrl }
      }));
    }
  };

  const handleFileUpload = async (docId: string) => {
    const fileState = selectedFiles[docId];
    if (!fileState?.file) return;

    setLoading(prev => ({ ...prev, [docId]: true }));
    const dateValue = (new Date());
    const formattedValue = moment(dateValue).format("DD-MM-YYYY");
    try {
      const docDTO = {
        applId,
        docId,
        docAsodt: formattedValue,
      };

      await DocumentAPI.uploadDocument(fileState.file, docDTO);
      await fetchUploadedDocs(docId);

      if (fileState.previewUrl) {
        URL.revokeObjectURL(fileState.previewUrl);
      }

      setSelectedFiles(prev => {
        const newState = { ...prev };
        delete newState[docId];
        return newState;
      });

      showError('Document uploaded successfully', 'success');
    } catch (error: any) {
      showError(error.response?.data?.message || 'Failed to upload document');
    } finally {
      setLoading(prev => ({ ...prev, [docId]: false }));
    }
  };

  const handleDownload = async (docUrlPath: string, filename: string, docId: number) => {
    setDownloadLoading(prev => ({ ...prev, [docId]: true }));
    try {
      const response = await DocumentAPI.downloadDocument(docUrlPath);
      const downloadLink = document.createElement('a');
      downloadLink.href = URL.createObjectURL(new Blob([response.data]));
      downloadLink.download = filename;
      downloadLink.target = '_blank';
      downloadLink.click();
    } catch (error: any) {
      showError(error.response?.data?.message || 'Failed to download document');
    } finally {
      setDownloadLoading(prev => ({ ...prev, [docId]: false }));
    }
  };

  const handleSampleDownload = async (docId: string) => {
    setSampleDownloadLoading(prev => ({ ...prev, [docId]: true }));
    try {
      const response = await DocumentAPI.downloadSampleDoc(docId);
      const downloadLink = document.createElement('a');
      downloadLink.href = URL.createObjectURL(new Blob([response.data]));
      downloadLink.download = `Bank Mandate_SAMPLE.pdf`;
      downloadLink.target = '_blank';
      downloadLink.click();
    } catch (error: any) {
      showError(error.response?.data?.message || 'Failed to download sample document');
    } finally {
      setSampleDownloadLoading(prev => ({ ...prev, [docId]: false }));
    }
  };

  const handleDeleteDocument = async (applId: string, slNo: number, docId: any) => {
    try {
      const deleteData =
      {
        "applId": applId,
        "slNo": slNo,
        "docId": docId,
        "filename": "",
        "filetype": "",
        "docUrlPath": ""
      }
      await DocumentAPI.deleteDocumentDoc(deleteData);
      showError('Document deleted successfully', 'success');
      if (selectedDocId) {
        await fetchUploadedDocs(selectedDocId);
      }
    } catch (error: any) {
      showError(error.response?.data?.message || 'Failed to delete document');
    }
  };

  const handlePreviewDownload = (docId: string) => {
    const fileState = selectedFiles[docId];
    if (fileState?.file) {
      const url = URL.createObjectURL(fileState.file);
      window.open(url, '_blank');
    }
  };

  const handleRemoveFile = (docId: string) => {
    const fileState = selectedFiles[docId];
    if (fileState?.previewUrl) {
      URL.revokeObjectURL(fileState.previewUrl);
    }

    setSelectedFiles(prev => {
      const newState = { ...prev };
      delete newState[docId];
      return newState;
    });
  };

  const handleOpenDrawer = async (docId: string) => {
    setSelectedDocId(docId);
    await fetchUploadedDocs(docId);
    setDrawerOpen(true);
  };

  const handleCloseDrawer = () => {
    setDrawerOpen(false);
    setSelectedDocId(null);
  };

  useEffect(() => {
    fetchDocumentList();
    return () => {
      Object.values(selectedFiles).forEach(fileState => {
        if (fileState?.previewUrl) {
          URL.revokeObjectURL(fileState.previewUrl);
        }
      });
    };
  }, [applId]);

  useEffect(() => {
    fetchDocumentList();
  }, [drawerOpen])

  const renderDrawerContent = () => {
    if (!selectedDocId) return null;
    const selectedDoc = documentDetails?.find(doc => doc.docId === selectedDocId);
    const uploadedDocsList = uploadedDocs[selectedDocId] || [];

    return (
      <Box sx={{ width: 400, p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Typography><b>Upload Documents</b></Typography>
          <IconButton onClick={handleCloseDrawer}>
            <CloseIcon />
          </IconButton>
        </Box>

        <Typography variant="subtitle1" sx={{ mb: 3 }} style={{
          fontSize: '13px',
          lineHeight: '20px', borderRadius: '4px', padding: '10px', background: '#bed3f5'
        }}>
          {selectedDoc?.docDesc}
        </Typography>

        {selectedDoc?.sampleFormatFlg === "Y" && (
          <Button
            variant="outlined"
            startIcon={sampleDownloadLoading[selectedDocId] ?
              <CircularProgress size={20} /> :
              <SampleDownloadIcon />
            }
            onClick={() => handleSampleDownload(selectedDocId)}
            disabled={sampleDownloadLoading[selectedDocId]}
            sx={{ mb: 2 }}
          >
            Download Sample
          </Button>
        )}

        <Box sx={{ mb: 3 }}>
          <input
            type="file"
            style={{ display: 'none' }}
            id={`drawer-file-upload-${selectedDocId}`}
            onChange={(e) => handleFileChange(selectedDocId, e)}
            accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.xls,.xlsx"
          />

          <label htmlFor={`drawer-file-upload-${selectedDocId}`}>
            <Button
              variant="outlined"
              component="span"
              startIcon={<SnippetFolderIcon />}
              sx={{ mr: 2, textTransform: 'capitalize' }}
            >    &nbsp; Choose File
            </Button>
          </label>

          {selectedFiles[selectedDocId]?.file && (
            <Box sx={{ mt: 2 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                <FileIcon sx={{ mr: 1 }} />
                <Typography variant="body2">
                  {selectedFiles[selectedDocId]?.file?.name}
                </Typography>
              </Box>

              <Box sx={{ display: 'flex', gap: 1 }}>
                <Button
                  size="small"
                  variant="outlined"
                  onClick={() => handlePreviewDownload(selectedDocId)}
                  startIcon={<PreviewIcon />}
                >
                  Preview
                </Button>

                <Button
                  size="small"
                  className='sbmtBtn'
                  variant="contained"
                  onClick={() => handleFileUpload(selectedDocId)}
                  disabled={loading[selectedDocId]}
                  startIcon={loading[selectedDocId] ? <CircularProgress size={20} /> : <SaveIcon />}
                >
                  Save
                </Button>

                <IconButton
                  size="small"
                  onClick={() => handleRemoveFile(selectedDocId)}
                  color="error"
                >


                  <DeleteIcon style={{ fontSize: '20px' }} />
                </IconButton>
              </Box>
            </Box>
          )}
        </Box>

        <Divider sx={{ my: 2 }} />
        <div style={{ background: '#fafafa', border: '1px solid #eee', display: 'block', padding: "10px", borderRadius: '5px', overflow: 'auto' }}>
          <Typography variant="subtitle1">
            <b>Uploaded Documents</b>
          </Typography>

          <List>
            {uploadedDocsList && uploadedDocsList?.length > 0 && uploadedDocsList?.map((doc: UploadedDocument) => (
              <ListItem
                key={doc.slNo}
                sx={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  mb: 1,
                  padding: '5px',
                  border: '1px solid #bed3f5',
                  borderRadius: '4px',
                  background: '#fff',
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                  <FileIcon sx={{ mr: 1 }} style={{ fontSize: '20px' }} />
                  <Typography variant="body2">{doc.filename}</Typography>
                </Box>
                <Box sx={{ display: 'flex', gap: 1 }}>
                  <Button
                    size="small"
                    variant="outlined"
                    onClick={() => handleDownload(doc.docUrlPath, doc.filename, doc.slNo)}
                    startIcon={downloadLoading[doc.slNo] ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={downloadLoading[doc.slNo]}
                  >
                    Download
                  </Button>
                  <IconButton
                    size="small"
                    color="error"
                    onClick={() => setDeleteDialog({
                      open: true,
                      applId: doc.applId,
                      slNo: doc.slNo,
                      filename: doc.filename,
                      docId: doc.docId
                    })}
                  >
                    <DeleteIcon style={{ fontSize: '20px' }} />
                  </IconButton>
                </Box>
              </ListItem>
            ))}
          </List>
        </div>
      </Box>
    );
  };

  if (pageLoading) {
    return (
      <Backdrop open={true} sx={{ color: '#fff', zIndex: 1000 }}>
        <CircularProgress color="inherit" />
      </Backdrop>
    );
  }

  return (
    <>
      <Card sx={{ padding: 2 }}>
        <Grid container spacing={2} className='pt-2'>
          {documentDetails?.map((doc) => (
            <Grid item xs={12} key={doc.docId} className="pt-2">
              <Grid container>
                <Grid item xs={12}>
                  <div className='docUpl'>
                    <Grid container>
                      <Grid item xs={7} className='df'>
                        <Typography variant="body2">
                          {doc.docDesc}

                          {doc.mandtoryFlg === "M" && (
                            <span style={{ color: 'red', marginLeft: '4px',fontSize:"1.2rem" }}>*</span>
                          )}

                        </Typography>
                      </Grid>
                      <Grid item xs={5}>
                        <Box className='df'>
                          <Button
                            variant="contained"
                            size="small"
                            onClick={() => handleOpenDrawer(doc.docId)}
                            startIcon={<UploadIcon />}
                          >
                            Upload Documents ({doc?.countOfRecord})
                          </Button>

                          {doc.sampleFormatFlg === 'Y' && (
                            <Button
                              className='ms-3'
                              variant="outlined"
                              size="small"
                              onClick={() => handleSampleDownload(doc.docId)}
                              startIcon={sampleDownloadLoading[doc.docId] ?
                                <CircularProgress size={20} /> :
                                <SampleDownloadIcon />
                              }
                              disabled={sampleDownloadLoading[doc.docId]}
                            >
                              Sample Format
                            </Button>
                          )}
                        </Box>
                      </Grid>
                    </Grid>
                  </div>
                </Grid>
              </Grid>
            </Grid>
          ))}
        </Grid>
      </Card>

      <Drawer
        anchor="right"
        open={drawerOpen}
        onClose={handleCloseDrawer}
      >
        {renderDrawerContent()}
      </Drawer>

      <Dialog className="cmn_popup"
        open={deleteDialog.open}
        onClose={() => setDeleteDialog({ open: false })}
      >
        <DialogTitle><h6><b>Confirm Delete</b></h6></DialogTitle>
        <DialogContent>
          <Typography>
            <p className='title'><ReportProblemIcon /> &nbsp; Are you sure you want to delete the document: {deleteDialog.filename}?</p>
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button
            color="error"
            variant="outlined"
            onClick={() => setDeleteDialog({ open: false })}>
            Cancel &nbsp; <HighlightOffIcon />
          </Button>
          <Button
            color="error"
            variant="contained"
            onClick={() => {
              if (deleteDialog.applId && deleteDialog.slNo) {
                handleDeleteDocument(deleteDialog.applId, deleteDialog.slNo, deleteDialog?.docId);
                setDeleteDialog({ open: false });
              }
            }}
          >
            Delete &nbsp;<DeleteIcon />
          </Button>
        </DialogActions>
      </Dialog>

      <Snackbar
        open={!!error}
        autoHideDuration={6000}
        onClose={handleCloseError}
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        <Alert
          onClose={handleCloseError}
          severity={error?.severity || 'error'}
          sx={{ width: '100%' }}
        >
          {error?.message}
        </Alert>
      </Snackbar>
    </>
  );
};

export default DocumentUploads;

import axios from 'axios';

const API_BASE_URL = `${process.env.REACT_APP_API_ENDPOINT}/refapi`;

const getHeaders = (isMultipart = false) => {
    const refJwtTokenData: any = localStorage.getItem('refJwtToken') ?? null;
    const jwtTokenData = refJwtTokenData !== null && refJwtTokenData ? JSON.parse(refJwtTokenData) : "";
    return {
        'Content-Type': isMultipart ? 'multipart/form-data' : 'application/json',
        'Authorization': `Bearer ${jwtTokenData}`
    };
};

export const DocumentAPI = {
    getDocumentList: (applId: string) => {
        return axios.get(`${API_BASE_URL}/appl/getMasterDocWithCount/${applId}`, {
            headers: getHeaders()
        });
    },

    getUploadedDocList: (applId: string, docId: string) => {
        return axios.get(`${API_BASE_URL}/appl/getUploadDocList/${applId}/${docId}`, {
            headers: getHeaders()
        });
    },

    uploadDocument: (file: File, docDTO: any) => {
        const formData = new FormData();
        formData.append('doc', file);
        formData.append('docDTO', new Blob([JSON.stringify(docDTO)], { type: 'application/json' }));
        return axios.post(`${API_BASE_URL}/appl/saveOnlineMainDoc`, formData, {
            headers: getHeaders(true)
        });
    },

    downloadDocument: (fileUrl: string) => {
        return axios.post(
            `${API_BASE_URL}/appl/download`,
            { fileUrl },
            {
                headers: getHeaders(),
                responseType: 'arraybuffer'
            }
        );
    },

    downloadSampleDoc: (docId: string) => {
        return axios.post(
            `${API_BASE_URL}/appl/downSample`,
            { docId },
            {
                headers: getHeaders(),
                responseType: 'arraybuffer'
            }
        );
    },


    downloadExternalTemplate: (docId:any,schemeCode:any) => {
        return axios.post(
            `${API_BASE_URL}/appl/downSectionTemplate?sectionId=${docId}&schCode=${schemeCode}`,
            {},
            {
                headers: getHeaders(),
                responseType: 'arraybuffer'
            }
        );
    },

    deleteDocumentDoc: (formData: any) => {
        return axios.delete(`${API_BASE_URL}/appl/delOnlineMainDoc`, {
            headers: getHeaders(),
            data: formData
        });
    }
};

/refapi/appl/submitOnlineDocs
Request payload -
{
  "applId": "N000004451",
  "docSaveStatus": "02"
}
 
Response -
Success
List of mandatory docs missing
Error 


/appl/getOnlineDocUploadSaveStatus/{applId}

Response - docSaveStatus as String value (or null if no data or "error" in case of error)



