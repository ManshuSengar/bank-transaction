
import { useEffect, useRef, useState } from 'react';
import dayjs from 'dayjs';
import Grid from "@mui/material/Grid";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { getIn, useFormikContext } from "formik";
import Checkbox from '@mui/material/Checkbox';
import Radio from '@mui/material/Radio';
import RadioGroup from '@mui/material/RadioGroup';
import FormControlLabel from '@mui/material/FormControlLabel';
import FormControl from '@mui/material/FormControl';
import FormLabel from '@mui/material/FormLabel';
import FormHelperText from '@mui/material/FormHelperText';
import moment from 'moment';
import { Typography } from '@mui/material';
type BaseFieldProps = {
    name: string;
    label?: string;
    disabled?: boolean;
    required?: boolean;
    helperText?: string;
    className?: string;
    onChange?: (value: any) => void;
    onBlur?: () => void;
}

type DatePickerFieldProps = BaseFieldProps & {
    disablePast?: boolean;
    disableFuture?: boolean;
    minDate?: Date;
    maxDate?: Date;
    views?: Array<'year' | 'month' | 'day'>;
    format?: string;
    showTimeSelect?: boolean;
    customValidation?: (date: Date) => boolean;
    onDateChange?: (date: Date | null) => void;
}

type CheckboxFieldProps = BaseFieldProps & {
    checkboxLabel?: string;
    indeterminate?: boolean;
    size?: 'small' | 'medium';
    color?: 'primary' | 'secondary' | 'error' | 'warning' | 'info' | 'success';
}

type RadioGroupFieldProps = BaseFieldProps & {
    options: Array<{
        value: string | number;
        label: string;
        disabled?: boolean;
    }>;
    row?: boolean;
    size?: 'small' | 'medium';
    color?: 'primary' | 'secondary' | 'error' | 'warning' | 'info' | 'success';
}


export const AdvanceDatePickerField = ({
    name,
    label,
    disabled = false,
    required = false,
    helperText,
    className,
    disablePast = false,
    disableFuture = false,
    minDate,
    maxDate,
    views = ['year', 'month', 'day'],
    format = "DD-MM-YYYY",
    showTimeSelect = false,
    customValidation,
    onDateChange,
    onChange,
    onBlur,
}: DatePickerFieldProps) => {
    const { values, touched, errors, setFieldValue, setFieldTouched } = useFormikContext();
    const [isOpen, setIsOpen] = useState(false);
    const currentValue = getIn(values, name);
    const errorMessage = getIn(touched, name) && getIn(errors, name);

    const shouldDisableDate = (date: dayjs.Dayjs) => {
        const currentDate = dayjs().startOf('day');

        if (disablePast && date.isBefore(currentDate, 'day')) {
            return true;
        }

        if (disableFuture && date.isAfter(currentDate, 'day')) {
            return true;
        }

        if (minDate && date.isBefore(dayjs(minDate), 'day')) {
            return true;
        }

        if (maxDate && date.isAfter(dayjs(maxDate), 'day')) {
            return true;
        }

        if (customValidation) {
            return !customValidation(date.toDate());
        }

        return false;
    };

    const handleDateChange = (newDate: dayjs.Dayjs | null) => {
        try {
            if (!newDate) {
                setFieldValue(name, null);
                onDateChange?.(null);
                onChange?.(null);
                return;
            }

            // Ensure the date is start of day to avoid time issues
            const formattedDate = newDate.startOf('day');

            // Check if the date should be disabled
            if (shouldDisableDate(formattedDate)) {
                return;
            }

            const dateValue = formattedDate.toDate();
            const formattedValue = moment(dateValue).format("DD-MM-YYYY");

            setFieldValue(name, formattedValue);
            onDateChange?.(dateValue);
            onChange?.(dateValue);
        } catch (error) {
            console.error('Error handling date change:', error);
        }
    };

    return (
        <Grid item xs={12} className={className}>
            <LocalizationProvider dateAdapter={AdapterDayjs}>
                <DatePicker
                    value={currentValue ? dayjs(currentValue, "DD-MM-YYYY") : null}
                    disabled={disabled}
                    onChange={handleDateChange}
                    label={required ? `${label} *` : label}
                    format={format}
                    views={views}
                    shouldDisableDate={shouldDisableDate}
                    onOpen={() => setIsOpen(true)}
                    onClose={() => setIsOpen(false)}
                    slotProps={{
                        textField: {
                            size: 'small',
                            fullWidth: true,
                            error: !!errorMessage,
                            onBlur: () => {
                                setFieldTouched(name, true);
                                onBlur?.();
                            },
                            helperText: errorMessage || helperText
                        },
                        popper: {
                            placement: 'bottom-start'
                        }
                    }}
                />
            </LocalizationProvider>
        </Grid>
    );
};




export const CheckboxField: React.FC<CheckboxFieldProps> = ({
    name,
    label,
    checkboxLabel,
    disabled = false,
    required = false,
    helperText,
    className,
    indeterminate = false,
    size = 'medium',
    color = 'primary',
    onChange,
    onBlur,
}) => {
    const {
        values,
        touched,
        errors,
        setFieldValue,
        setFieldTouched
    } = useFormikContext();

    const currentValue = getIn(values, name);
    const errorMessage = getIn(touched, name) && getIn(errors, name);

    const isChecked = currentValue === 'Y' || currentValue === true;

    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const newValue = event.target.checked ? 'Y' : 'N';

        try {
            setFieldValue(name, newValue, true);
            setFieldTouched(name, true);

            onChange?.(event.target.checked);
        } catch (error) {
            console.error(`Error in CheckboxField (${name}):`, error);
        }
    };

    const handleBlur = () => {
        try {
            setFieldTouched(name, true);
            onBlur?.();
        } catch (error) {
            console.error(`Error in CheckboxField blur (${name}):`, error);
        }
    };

    return (
        <FormControl
            required={required}
            error={!!errorMessage}
            disabled={disabled}
            className={className}
        >
            <FormControlLabel
                control={
                    <Checkbox
                        checked={isChecked}
                        indeterminate={indeterminate}
                        onChange={handleChange}
                        onBlur={handleBlur}
                        size={size}
                        color={color}
                    />
                }
                label={checkboxLabel ?? label}
            />
            {(errorMessage || helperText) && (
                <FormHelperText>
                    {errorMessage || helperText}
                </FormHelperText>
            )}
        </FormControl>
    );
};



export const RadioGroupField = ({
    name,
    label,
    options,
    disabled = false,
    required = false,
    helperText,
    className,
    row = false,
    size = 'medium',
    color = 'primary',
    onChange,
    onBlur,
}: RadioGroupFieldProps) => {
    const { values, touched, errors, setFieldValue, setFieldTouched } = useFormikContext();
    const currentValue = getIn(values, name);
    const errorMessage = getIn(touched, name) && getIn(errors, name);

    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const newValue = event.target.value;
        setFieldValue(name, newValue, true);
        onChange?.(newValue);
    };

    return (
        <FormControl
            required={required}
            error={!!errorMessage}
            disabled={disabled}
            className={`${className} ${disabled ? 'disabled-radio-css' : ''}`}
        >
            <FormLabel>{label}</FormLabel>
            <RadioGroup
                row={row}
                name={name}
                value={currentValue || ''}
                onChange={handleChange}
                onClick={() => {
                    setFieldTouched(name, true);
                    onBlur?.();
                }}
                onBlur={() => {
                    setFieldTouched(name, true);
                    onBlur?.();
                }}
            >
                {options.map((option) => (
                    <FormControlLabel
                        key={option.value}
                        value={option.value}

                        control={
                            <Radio
                                size={size}
                                color={color}
                                disabled={option.disabled || disabled}
                            />
                        }
                        label={option.label}
                        disabled={option.disabled || disabled}

                    />
                ))}
            </RadioGroup>
            {(errorMessage || helperText) && (
                <FormHelperText>{errorMessage || helperText}</FormHelperText>
            )}
        </FormControl>
    );
};







import React, { useEffect, useRef, useState } from 'react';
import { Table, TableBody, TableCell, TableHead, TableRow, Button, Grid } from "@mui/material";
import { Formik, Form, useFormikContext } from 'formik';
import * as Yup from 'yup';
import { useGetapplprestproposalQuery, useGetMemorandumTxtQuery, useSaveApplPrestProposalMutation, useSaveMemorandumTxtMutation } from '../../../features/monitoring/interestRateFixationApi';
import NbfcSnackbar from '../../../components/shared/NbfcSnackbar';
import { AdvanceTextBoxField } from '../../../components/framework/AdvanceTextBoxField';
import { AdvanceDatePickerField } from '../../../components/framework/EnhancedComponents';
import { EnhancedDropDown } from '../../../components/framework/EnhancedDropDown';
import AutoSave from '../../../components/framework/AutoSave';
import { RichTextField } from '../../../components/framework/RichTextField';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import { useGetBenchMarkQuery } from '../../../features/appraisal/shareholdingDetailsApi';
import { useSaveCurntRateByRateIDAndAsOnDateMutation } from '../../../features/monitoring/interestResetApi';


const InterestRateApplicable = ({ irfId }: any) => {
  const { data: proposalData, isLoading } = useGetapplprestproposalQuery(irfId, {
    skip: !irfId,
    refetchOnMountOrArgChange: true,
  });

  const { data: memorandumData, isLoading: isLoadingMemorandum } = useGetMemorandumTxtQuery(irfId, {
    skip: !irfId,
    refetchOnMountOrArgChange: true,
  });

  const { data: benchmarkData, isLoading: isLoadingBenchmark } = useGetBenchMarkQuery("");

  const [options, setOptions] = useState<any[]>([]);
  const [selectedValue, setSelectedValue] = useState<any>("");
  const [selectedLabel, setSelectedLabel] = useState<any>("");

  useEffect(() => {
    if (benchmarkData) {
      const transformed = benchmarkData.map((item: any) => ({
        key: item.BRM_RATE_ID,
        value: item.BRM_RATE_ID,
        label: item.BRM_RATE_NAME
      }));
      setOptions(transformed);
      if (proposalData?.[0]?.proposalType) {
        const selectedOption = transformed.find((opt: any) => opt.value === proposalData[0].proposalType);
        if (selectedOption) {
          setSelectedValue(selectedOption.value);
          setSelectedLabel(selectedOption.label);
        }
      }
    }
  }, [benchmarkData, proposalData]);

  const handleChange = (value: any, setFieldValue: any) => {
    setSelectedValue(value);
    const selected = options.find((opt: any) => opt.value === value);
    if (selected) {
      setSelectedLabel(selected.label);
      setFieldValue('proposalType', value);
    }
  };

  const [saveMemorandumTxt] = useSaveMemorandumTxtMutation();

  const handleSubmitMemorandum = async (values: any) => {
    try {
      const finalValue = {
        ...values,
        irfId,
        saveStatus: '01',
        preprosalComment: values?.preprosalComment,
      };
      await saveMemorandumTxt(finalValue).unwrap();
      setOpenSnackbar(true);
      setSeverity("success");
      setSnackMsg("Memorandum saved successfully");
    } catch (error) {
      console.error("Error saving memorandum:", error);
      setOpenSnackbar(true);
      setSeverity("error");
      setSnackMsg("Failed to save Memorandum");
    }
  };

  const [saveApplPrestProposal] = useSaveApplPrestProposalMutation();
  const [getBenchmarkDate] = useSaveCurntRateByRateIDAndAsOnDateMutation();
  const [openSnackbar, setOpenSnackbar] = useState(false);
  const [snackMsg, setSnackMsg] = useState("");
  const [severity, setSeverity] = useState("success");

  const initialValues = proposalData?.[0] || {
    proposalType: '',
    mclr: '',
    ratingSpread: '',
    intScore: '',
    intScoreLink: '',
    totalSpread: '',
    finalRate: '',
    grade: '',
    benchmarkAsOn: '',
    tenure: '',
    benchmark: '',
    benchmarkRate: '',
    sidbiSpread: '',
    minIntRate: '',
    minIntRateTrmv: '',
    interestType: ''
  };

  const validationSchema = Yup.object().shape({
    interestType: Yup.string().required('Interest Type is required'),
    // proposalType: Yup.string().when('interestType', {
    //   is: 'floating',
    //   then: Yup.string().required('Proposal Type is required'),
    //   otherwise: Yup.string().nullable()
    // }),
  });

  const handleSubmit = async (values: any) => {
    try {
      const dataToSave = { ...values, irfId, saveStatus: '01' };
      await saveApplPrestProposal(dataToSave).unwrap();
      setOpenSnackbar(true);
      setSeverity("success");
      setSnackMsg("Proposal saved successfully");
    } catch (error) {
      console.error("Error saving proposal:", error);
      setOpenSnackbar(true);
      setSeverity("error");
      setSnackMsg("Failed to save proposal");
    }
  };

  const handleSnackClose = () => setOpenSnackbar(false);

  if (isLoading || isLoadingMemorandum || isLoadingBenchmark) return <p>Loading...</p>;

  const InnerForm = () => {
    const { values, setFieldValue, setValues }: any = useFormikContext();
    const prevInterestTypeRef = useRef<any>(values?.interestType);
    const prevProposalTypeRef = useRef<any>(values?.proposalType);

    useEffect(() => {
      if (prevInterestTypeRef.current !== values?.interestType) {
        setValues({
          mclr: '',
          ratingSpread: '',
          intScore: '',
          intScoreLink: '',
          totalSpread: '',
          finalRate: '',
          grade: '',
          benchmarkAsOn: '',
          tenure: '',
          benchmark: '',
          benchmarkRate: '',
          sidbiSpread: '',
          minIntRate: '',
          minIntRateTrmv: '',
          interestType: values?.interestType,
          proposalType: values?.interestType === 'floating' ? '' : null,
        });
        if (values?.interestType === 'floating') {
          setSelectedValue('');
          setSelectedLabel('');
        }
        prevInterestTypeRef.current = values?.interestType;
      } else if (values?.interestType === 'floating' && prevProposalTypeRef.current !== values?.proposalType) {
        setValues({
          mclr: '',
          ratingSpread: '',
          intScore: '',
          intScoreLink: '',
          totalSpread: '',
          finalRate: '',
          grade: '',
          benchmarkAsOn: '',
          tenure: '',
          benchmark: '',
          benchmarkRate: '',
          sidbiSpread: '',
          minIntRate: '',
          minIntRateTrmv: '',
          interestType: values?.interestType,
          proposalType: values?.proposalType,
        });
        prevProposalTypeRef.current = values?.proposalType;
      }
    }, [values?.interestType, values?.proposalType, setValues]);

    useEffect(() => {
      if (selectedLabel !== '3 Month T-Bill') {
        const baseSpread = parseFloat(values.ratingSpread) || 0;
        const intScoreLink = parseFloat(values.intScoreLink) || 0;
        const totalSpread = baseSpread + intScoreLink;
        setFieldValue('totalSpread', totalSpread.toFixed(2));
        const mclr = parseFloat(values.mclr) || 0;
        const finalRate = mclr + totalSpread;
        setFieldValue('finalRate', finalRate.toFixed(2));
      }
    }, [values.ratingSpread, values.intScoreLink, values.mclr, selectedLabel, setFieldValue]);

    useEffect(() => {
      if (values?.interestType === 'fixed') {
        const fimmdaSpread = parseFloat(values.ratingSpread) || 0;
        const sidbiSpread = parseFloat(values.sidbiSpread) || 0;
        const totalSpread = fimmdaSpread + sidbiSpread;
        setFieldValue('totalSpread', totalSpread.toFixed(2));
        const benchmarkRate = parseFloat(values.benchmarkRate) || 0;
        const minIntRate = benchmarkRate + totalSpread;
        setFieldValue('minIntRate', minIntRate.toFixed(2));
        const minIntRateTrmv = parseFloat(values.minIntRateTrmv) || 0;
        const finalRate = Math.max(minIntRate, minIntRateTrmv);
        setFieldValue('finalRate', finalRate.toFixed(2));
      }
    }, [values.ratingSpread, values.sidbiSpread, values.benchmarkRate, values.minIntRateTrmv, values.interestType, setFieldValue]);

    useEffect(() => {
      if (selectedLabel === '3 Month T-Bill') {
        const ratingSpread = parseFloat(values.ratingSpread) || 0;
        const sidbiSpread = parseFloat(values.sidbiSpread) || 0;
        const totalSpread = ratingSpread + sidbiSpread;
        setFieldValue('totalSpread', totalSpread.toFixed(2));
        const benchmarkRate = parseFloat(values.benchmarkRate) || 0;
        const minIntRate = benchmarkRate + totalSpread;
        setFieldValue('minIntRate', minIntRate.toFixed(2));
        const minIntRateTrmv = parseFloat(values.minIntRateTrmv) || 0;
        const finalRate = Math.max(minIntRate, minIntRateTrmv);
        setFieldValue('finalRate', finalRate.toFixed(2));
      }
    }, [values.ratingSpread, values.sidbiSpread, values.benchmarkRate, values.minIntRateTrmv, selectedLabel, setFieldValue]);

    return (
      <Form>
        <Grid item xs={12} sm={4} md={4} lg={4}>
          <EnhancedDropDown
            label="Interest Type"
            name="interestType"
            customOptions={[
              { key: 'fixed', value: 'fixed', label: 'Fixed' },
              { key: 'floating', value: 'floating', label: 'Floating' },
            ]}
            domain=""
          />
        </Grid>

        {values?.interestType === "floating" && (
          <Grid item xs={12} sm={4} md={4} lg={4}>
            <EnhancedDropDown
              label="Proposal Type"
              name="proposalType"
              customOptions={options}
              onChange={(value: any) => handleChange(value, setFieldValue)}
              domain=""
            />
          </Grid>
        )}

        {values?.interestType === 'fixed' && (
          <Table sx={{ minWidth: 650 }} aria-label="fixed table" className="mt-4">
            <TableHead>
              <TableRow>
                <TableCell colSpan={10}><h6><b>Interest Rate applicable for present proposal - Fixed</b></h6></TableCell>
              </TableRow>
              <TableRow>
                <TableCell><b>Rating Grade</b></TableCell>
                <TableCell><b>Daily yield matrix as on</b></TableCell>
                <TableCell><b>Tenure</b></TableCell>
                <TableCell><b>FIMMDA yield (Benchmark)</b></TableCell>
                <TableCell><b>FIMMDA Spread</b></TableCell>
                <TableCell><b>SIDBI Spread</b></TableCell>
                <TableCell><b>Total Spread</b></TableCell>
                <TableCell><b>Minimum Interest Rate</b></TableCell>
                <TableCell><b>TRMV Interest Rate</b></TableCell>
                <TableCell><b>Final Rate</b></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              <TableRow>
                <TableCell><AdvanceTextBoxField label="" name="grade" type="text" /></TableCell>
                <TableCell><AdvanceDatePickerField label="" name="benchmarkAsOn" disableFuture={true} /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="tenure" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="benchmarkRate" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="ratingSpread" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="sidbiSpread" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="totalSpread" type="number" disabled={true} /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="minIntRate" type="number" disabled={true} /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="minIntRateTrmv" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="" name="finalRate" type="number" disabled={true} /></TableCell>
              </TableRow>
            </TableBody>
          </Table>
        )}

        {(values?.interestType === "floating" && (selectedLabel !== "3 Month T-Bill" )) && (
          <Table sx={{ minWidth: 650 }} aria-label="mclr table" className="mt-4">
            <TableHead>
              <TableRow>
                <TableCell colSpan={6}><h6><b>Interest Rate applicable for present proposal - {selectedLabel}</b></h6></TableCell>
              </TableRow>
              <TableRow>
                <TableCell style={{ width: '9%' }}><b>Benchmark Rate</b></TableCell>
                <TableCell><b>Base Spread</b></TableCell>
                <TableCell><b>Internal Score</b></TableCell>
                <TableCell><b>Internal Score Linked Spread</b></TableCell>
                <TableCell><b>Total Spread</b></TableCell>
                <TableCell><b>Applicable Rate (%)</b></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              <TableRow>
                <TableCell><AdvanceTextBoxField label="%" name="mclr" disabled type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Base Spread" name="ratingSpread" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Internal Score" name="intScore" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Internal Score Linked Spread" name="intScoreLink" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Total Spread" name="totalSpread" type="number" disabled={true} /></TableCell>
                <TableCell><AdvanceTextBoxField label="Applicable Rate (%)" name="finalRate" type="number" disabled={true} /></TableCell>
              </TableRow>
            </TableBody>
          </Table>
        )}

        {(values?.interestType === "floating" && selectedLabel === "3 Month T-Bill") && (
          <Table sx={{ minWidth: 650 }} aria-label="tbill table" className="mt-4">
            <TableHead>
              <TableRow>
                <TableCell colSpan={10}><h6><b>Interest Rate applicable for present proposal - T-bill</b></h6></TableCell>
              </TableRow>
              <TableRow>
                <TableCell><b>Rating Grade</b></TableCell>
                <TableCell><b>Benchmark as on</b></TableCell>
                <TableCell><b>Benchmark</b></TableCell>
                <TableCell><b>Benchmark Rate</b></TableCell>
                <TableCell><b>Rating Spread (%)</b></TableCell>
                <TableCell><b>SIDBI Spread</b></TableCell>
                <TableCell><b>Total Spread</b></TableCell>
                <TableCell><b>Minimum Interest Rate</b></TableCell>
                <TableCell><b>TRMV Interest Rate</b></TableCell>
                <TableCell><b>Final Rate</b></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              <TableRow>
                <TableCell><AdvanceTextBoxField label="Rating Grade" name="grade" type="text" /></TableCell>
                <TableCell><AdvanceDatePickerField label="Benchmark as on" name="benchmarkAsOn" disableFuture={true}/></TableCell>
                <TableCell><AdvanceTextBoxField disabled value={selectedLabel} label="Benchmark" name="benchmark" type="text" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Benchmark Rate" name="benchmarkRate" type="number" disabled /></TableCell>
                <TableCell><AdvanceTextBoxField label="Rating Spread (%)" name="ratingSpread" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="SIDBI Spread" name="sidbiSpread" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Total Spread" name="totalSpread" type="number" disabled={true} /></TableCell>
                <TableCell><AdvanceTextBoxField label="Minimum Interest Rate" name="minIntRate" type="number" disabled={true} /></TableCell>
                <TableCell><AdvanceTextBoxField label="TRMV Interest Rate" name="minIntRateTrmv" type="number" /></TableCell>
                <TableCell><AdvanceTextBoxField label="Final Rate" name="finalRate" type="number" disabled={true} /></TableCell>
              </TableRow>
            </TableBody>
          </Table>
        )}

        <Button type="submit" variant="contained" color="primary" className="mt-2">Save</Button>
      </Form>
    );
  };

  return (
    <div className="wrap-inner-table mt-0">
      <Formik
        initialValues={initialValues}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
        enableReinitialize={true}
      >
        <InnerForm />
      </Formik>

      <Formik
        initialValues={{
          irValidity: memorandumData?.irValidity || null,
          dop: memorandumData?.dop || "",
          dopComments: memorandumData?.dopComments || "",
          discPowers: memorandumData?.discPowers || "",
          verticalComments: memorandumData?.verticalComments || "",
          recommendation: memorandumData?.recommendation || "",
          preprosalComment: memorandumData?.preprosalComment || "",
          rateReqComment: memorandumData?.rateReqComment || "",
          committeName: memorandumData?.committeName || ""
        }}
        onSubmit={handleSubmitMemorandum}
        enableReinitialize={true}
        validateOnChange={false}
        validateOnBlur={true}
      >
        {({ values }: any) => (
          <Form>
            <AutoSave debounceMs={5000} values={values} handleSubmit={handleSubmitMemorandum} />
            <Grid container spacing={2} padding={4} className='form-grid p-0'>
              <Grid item xs={12}>
                <Table sx={{ minWidth: 650 }} aria-label="validity table">
                  <TableBody>
                    <TableRow>
                      <TableCell>
                        <RichTextField label="Comments" name="preprosalComment" />
                      </TableCell>
                    </TableRow>
                  </TableBody>
                </Table>
              </Grid>
              <Grid item xs={12} sx={{ mt: 2 }}>
                <Button
                  className="sbmtBtn mt-0 mb-3 ms-2 me-2"
                  type="submit"
                  variant="contained"
                >
                  Save <CheckCircleOutlineIcon />
                </Button>
              </Grid>
            </Grid>
          </Form>
        )}
      </Formik>

      <NbfcSnackbar
        open={openSnackbar}
        msg={snackMsg}
        severity={severity}
        handleSnackClose={handleSnackClose}
        submitCall={false}
      />
    </div>
  );
};

export default InterestRateApplicable;



{
  "asOnDate": "24-JUN-2024",
  "benchMarkRateId": "16"
}

curl -X 'POST' \
  'https://dev-nbfc.sidbi.in/mon/mstr/getCurntRate' \
  -H 'accept: */*' \
  -H 'Content-Type: application/json' \
  -d '{
  "asOnDate": "24-JUN-2024",
  "benchMarkRateId": "16"
}'

{
  "data": "6.8",
  "message": "Success",
  "status": 200
}
import React from 'react';
import Grid from "@mui/material/Grid";
import { KeyValuePair } from "./KeyValuePair";
import { getIn, useFormikContext } from "formik";
import Typography from "@mui/material/Typography";
import { removeRestrictedCharacters } from '../../utlis/input';
import { InputAdornment, Tooltip, IconButton } from '@mui/material';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import RedditTextField from './RedditTextField';


interface AdvanceTextBoxFieldProps {
  id?: number;
  label?: string;
  name: string;
  disabled?: boolean;
  type?: string;
  value?: string;
  readonly?: boolean;
  restrictedCharacters?: string;
  placeholder?: string;
  tooltip?: string;
  required?: boolean;
  maxLength?: number;
  minLength?: number;
  startAdornment?: React.ReactNode;
  endAdornment?: React.ReactNode;
  multiline?: boolean;
  rows?: number;
  maxRows?: number;
  validation?: {
    pattern?: RegExp;
    customValidation?: (value: string) => string | undefined;
  };
  transformValue?: (value: string) => string;
  onCustomChange?: any;
  fullWidth?: boolean;
  className?: string;
  style?: React.CSSProperties;
  InputProps?: any;
  allowNegative?: boolean;
  allowDecimal?: boolean;
  decimalPlaces?: number;
}

export const AdvanceTextBoxField: React.FC<AdvanceTextBoxFieldProps> = ({
  label = "",
  name,
  disabled = false,
  type = 'text',
  readonly = false,
  restrictedCharacters = "<>{}",
  placeholder,
  tooltip,
  required = false,
  maxLength,
  minLength,
  startAdornment,
  endAdornment,
  multiline = false,
  rows,
  maxRows,
  validation,
  transformValue,
  onCustomChange,
  fullWidth = true,
  className,
  style,
  allowNegative = false,
  allowDecimal = true,
  decimalPlaces = 2,
  ...props
}) => {
  const { handleChange, handleBlur, values, touched, errors, setFieldValue } =
    useFormikContext<KeyValuePair>() || {};

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    let { value } = event.target;

    if (restrictedCharacters) {
      value = removeRestrictedCharacters(value, restrictedCharacters);
    }

    if (transformValue) {
      value = transformValue(value);
    }

    if (type === 'number') {
      let regex = allowNegative ? /^-?\d*\.?\d{0,2}$/ : /^\d*\.?\d{0,2}$/;
      if (!allowDecimal) {
        regex = /^\d*$/;
      }
      if (allowNegative && !allowDecimal) {
        regex = /^-?\d*$/;
      }
      if (!regex.test(value) && value !== '') {
        return;
      }
      if (value !== '' && value !== '-' && allowDecimal && value.includes('.')) {
        const parts = value.split('.');
        if (parts[1] && parts[1].length > decimalPlaces) {
          const rounded = Number(parseFloat(value).toFixed(decimalPlaces));
          value = rounded.toString();
        }
      }
    }

    if (validation?.pattern && !validation.pattern.test(value)) {
      return;
    }
    setFieldValue(name, value);
    if (onCustomChange) {
      onCustomChange(value);
    }
  };
  const labelStyles = {
    '& .MuiInputLabel-shrink': {
      background: '#fff',
      padding: '0 8px',
    },
  };

  const getErrorMessage = () => {
    if (getIn(touched, name) && getIn(errors, name)) {
      return JSON.stringify(getIn(errors, name)).replaceAll('"', "");
    }
    return "";
  };

  return (
    <Grid item xs={12} style={style}>
      <Grid item xs={12}>
        <RedditTextField
          label={label}
          className={`${name} ${className || ''}`}
          onChange={handleInputChange}
          onBlur={handleBlur}
          value={getIn(values, name)}
          name={name}
          size="small"
          disabled={disabled}
          type={type}
          placeholder={placeholder}
          required={required}
          sx={labelStyles}
          inputProps={{
            readOnly: readonly,
            maxLength: maxLength,
            minLength: minLength,
            inputMode: type === 'number' ? 'decimal' : 'text',
            pattern: type === 'number' ? undefined : undefined
          }}
          multiline={multiline}
          rows={rows}
          maxRows={maxRows}
          fullWidth={fullWidth}
          InputProps={{
            startAdornment: startAdornment && (
              <InputAdornment position="start">{startAdornment}</InputAdornment>
            ),
            endAdornment: (
              <InputAdornment position="end">
                {tooltip && (
                  <Tooltip title={tooltip}>
                    <IconButton size="small">
                      <HelpOutlineIcon />
                    </IconButton>
                  </Tooltip>
                )}
                {endAdornment}
              </InputAdornment>
            ),
          }}
          {...props}
        />
      </Grid>
      <Grid item xs={12}>
        <Typography
          color="error"
          variant="subtitle2"
          gutterBottom
          component="span"
          className="mybooking_error"
        >
          {getErrorMessage()}
        </Typography>
      </Grid>
    </Grid>
  );
};





